Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    IF
    FOR
    DEFMODULE
    DEFSTRUCT
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> statements
Rule 2     program -> program statements
Rule 3     statements -> statement
Rule 4     statements -> statements statement
Rule 5     statement -> func_def
Rule 6     statement -> assign ;
Rule 7     statement -> expr ;
Rule 8     func_def -> DEF ID ( argument_list ) block
Rule 9     block -> { }
Rule 10    block -> { statements }
Rule 11    block -> { statements RETURN expr ; }
Rule 12    block -> { RETURN expr ; }
Rule 13    argument -> expr
Rule 14    argument -> default_assign
Rule 15    argument_list -> argument
Rule 16    argument_list -> argument , argument_list
Rule 17    function_argument -> expr
Rule 18    function_argument_list -> function_argument
Rule 19    function_argument_list -> function_argument , function_argument_list
Rule 20    assign -> CONST ID = expr
Rule 21    assign -> ID = expr
Rule 22    default_assign -> ID = expr
Rule 23    expr -> term
Rule 24    expr -> expr + term
Rule 25    expr -> expr - term
Rule 26    term -> factor
Rule 27    term -> term * factor
Rule 28    term -> term / factor
Rule 29    term -> term ^ factor
Rule 30    factor -> NUMBER
Rule 31    factor -> STRING
Rule 32    factor -> func_call
Rule 33    factor -> ID
Rule 34    factor -> ( expr )
Rule 35    func_call -> ID ( function_argument_list )

Terminals, with rules where they appear

(                    : 8 34 35
)                    : 8 34 35
*                    : 27
+                    : 24
,                    : 16 19
-                    : 25
/                    : 28
;                    : 6 7 11 12
=                    : 20 21 22
CONST                : 20
DEF                  : 8
DEFMODULE            : 
DEFSTRUCT            : 
FOR                  : 
ID                   : 8 20 21 22 33 35
IF                   : 
NUMBER               : 30
RETURN               : 11 12
STRING               : 31
WHILE                : 
^                    : 29
error                : 
{                    : 9 10 11 12
}                    : 9 10 11 12

Nonterminals, with rules where they appear

argument             : 15 16
argument_list        : 8 16
assign               : 6
block                : 8
default_assign       : 14
expr                 : 7 11 12 13 17 20 21 22 24 25 34
factor               : 26 27 28 29
func_call            : 32
func_def             : 5
function_argument    : 18 19
function_argument_list : 19 35
program              : 2 0
statement            : 3 4
statements           : 1 2 4 10 11
term                 : 23 24 25 27 28 29

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statements
    (2) program -> . program statements
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . func_def
    (6) statement -> . assign ;
    (7) statement -> . expr ;
    (8) func_def -> . DEF ID ( argument_list ) block
    (20) assign -> . CONST ID = expr
    (21) assign -> . ID = expr
    (23) expr -> . term
    (24) expr -> . expr + term
    (25) expr -> . expr - term
    (26) term -> . factor
    (27) term -> . term * factor
    (28) term -> . term / factor
    (29) term -> . term ^ factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

    DEF             shift and go to state 12
    CONST           shift and go to state 7
    ID              shift and go to state 15
    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    (               shift and go to state 2

    statement                      shift and go to state 1
    factor                         shift and go to state 4
    expr                           shift and go to state 8
    func_def                       shift and go to state 9
    term                           shift and go to state 5
    program                        shift and go to state 6
    statements                     shift and go to state 10
    assign                         shift and go to state 13
    func_call                      shift and go to state 14

state 1

    (3) statements -> statement .

    DEF             reduce using rule 3 (statements -> statement .)
    CONST           reduce using rule 3 (statements -> statement .)
    ID              reduce using rule 3 (statements -> statement .)
    NUMBER          reduce using rule 3 (statements -> statement .)
    STRING          reduce using rule 3 (statements -> statement .)
    (               reduce using rule 3 (statements -> statement .)
    $end            reduce using rule 3 (statements -> statement .)
    }               reduce using rule 3 (statements -> statement .)
    RETURN          reduce using rule 3 (statements -> statement .)


state 2

    (34) factor -> ( . expr )
    (23) expr -> . term
    (24) expr -> . expr + term
    (25) expr -> . expr - term
    (26) term -> . factor
    (27) term -> . term * factor
    (28) term -> . term / factor
    (29) term -> . term ^ factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    ID              shift and go to state 17
    (               shift and go to state 2

    expr                           shift and go to state 16
    func_call                      shift and go to state 14
    term                           shift and go to state 5
    factor                         shift and go to state 4

state 3

    (30) factor -> NUMBER .

    *               reduce using rule 30 (factor -> NUMBER .)
    /               reduce using rule 30 (factor -> NUMBER .)
    ^               reduce using rule 30 (factor -> NUMBER .)
    +               reduce using rule 30 (factor -> NUMBER .)
    -               reduce using rule 30 (factor -> NUMBER .)
    ;               reduce using rule 30 (factor -> NUMBER .)
    ,               reduce using rule 30 (factor -> NUMBER .)
    )               reduce using rule 30 (factor -> NUMBER .)


state 4

    (26) term -> factor .

    *               reduce using rule 26 (term -> factor .)
    /               reduce using rule 26 (term -> factor .)
    ^               reduce using rule 26 (term -> factor .)
    ;               reduce using rule 26 (term -> factor .)
    +               reduce using rule 26 (term -> factor .)
    -               reduce using rule 26 (term -> factor .)
    ,               reduce using rule 26 (term -> factor .)
    )               reduce using rule 26 (term -> factor .)


state 5

    (23) expr -> term .
    (27) term -> term . * factor
    (28) term -> term . / factor
    (29) term -> term . ^ factor

    +               reduce using rule 23 (expr -> term .)
    -               reduce using rule 23 (expr -> term .)
    ,               reduce using rule 23 (expr -> term .)
    )               reduce using rule 23 (expr -> term .)
    ;               reduce using rule 23 (expr -> term .)
    *               shift and go to state 18
    /               shift and go to state 20
    ^               shift and go to state 19


state 6

    (0) S' -> program .
    (2) program -> program . statements
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . func_def
    (6) statement -> . assign ;
    (7) statement -> . expr ;
    (8) func_def -> . DEF ID ( argument_list ) block
    (20) assign -> . CONST ID = expr
    (21) assign -> . ID = expr
    (23) expr -> . term
    (24) expr -> . expr + term
    (25) expr -> . expr - term
    (26) term -> . factor
    (27) term -> . term * factor
    (28) term -> . term / factor
    (29) term -> . term ^ factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

    DEF             shift and go to state 12
    CONST           shift and go to state 7
    ID              shift and go to state 15
    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    (               shift and go to state 2

    statement                      shift and go to state 1
    factor                         shift and go to state 4
    expr                           shift and go to state 8
    func_def                       shift and go to state 9
    term                           shift and go to state 5
    statements                     shift and go to state 21
    assign                         shift and go to state 13
    func_call                      shift and go to state 14

state 7

    (20) assign -> CONST . ID = expr

    ID              shift and go to state 22


state 8

    (7) statement -> expr . ;
    (24) expr -> expr . + term
    (25) expr -> expr . - term

    ;               shift and go to state 24
    +               shift and go to state 23
    -               shift and go to state 25


state 9

    (5) statement -> func_def .

    DEF             reduce using rule 5 (statement -> func_def .)
    CONST           reduce using rule 5 (statement -> func_def .)
    ID              reduce using rule 5 (statement -> func_def .)
    NUMBER          reduce using rule 5 (statement -> func_def .)
    STRING          reduce using rule 5 (statement -> func_def .)
    (               reduce using rule 5 (statement -> func_def .)
    $end            reduce using rule 5 (statement -> func_def .)
    }               reduce using rule 5 (statement -> func_def .)
    RETURN          reduce using rule 5 (statement -> func_def .)


state 10

    (1) program -> statements .
    (4) statements -> statements . statement
    (5) statement -> . func_def
    (6) statement -> . assign ;
    (7) statement -> . expr ;
    (8) func_def -> . DEF ID ( argument_list ) block
    (20) assign -> . CONST ID = expr
    (21) assign -> . ID = expr
    (23) expr -> . term
    (24) expr -> . expr + term
    (25) expr -> . expr - term
    (26) term -> . factor
    (27) term -> . term * factor
    (28) term -> . term / factor
    (29) term -> . term ^ factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for ( resolved as shift
    $end            reduce using rule 1 (program -> statements .)
    DEF             shift and go to state 12
    CONST           shift and go to state 7
    ID              shift and go to state 15
    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    (               shift and go to state 2

  ! DEF             [ reduce using rule 1 (program -> statements .) ]
  ! CONST           [ reduce using rule 1 (program -> statements .) ]
  ! ID              [ reduce using rule 1 (program -> statements .) ]
  ! NUMBER          [ reduce using rule 1 (program -> statements .) ]
  ! STRING          [ reduce using rule 1 (program -> statements .) ]
  ! (               [ reduce using rule 1 (program -> statements .) ]

    statement                      shift and go to state 26
    factor                         shift and go to state 4
    func_def                       shift and go to state 9
    expr                           shift and go to state 8
    assign                         shift and go to state 13
    term                           shift and go to state 5
    func_call                      shift and go to state 14

state 11

    (31) factor -> STRING .

    *               reduce using rule 31 (factor -> STRING .)
    /               reduce using rule 31 (factor -> STRING .)
    ^               reduce using rule 31 (factor -> STRING .)
    +               reduce using rule 31 (factor -> STRING .)
    -               reduce using rule 31 (factor -> STRING .)
    ;               reduce using rule 31 (factor -> STRING .)
    ,               reduce using rule 31 (factor -> STRING .)
    )               reduce using rule 31 (factor -> STRING .)


state 12

    (8) func_def -> DEF . ID ( argument_list ) block

    ID              shift and go to state 27


state 13

    (6) statement -> assign . ;

    ;               shift and go to state 28


state 14

    (32) factor -> func_call .

    *               reduce using rule 32 (factor -> func_call .)
    /               reduce using rule 32 (factor -> func_call .)
    ^               reduce using rule 32 (factor -> func_call .)
    +               reduce using rule 32 (factor -> func_call .)
    -               reduce using rule 32 (factor -> func_call .)
    ;               reduce using rule 32 (factor -> func_call .)
    ,               reduce using rule 32 (factor -> func_call .)
    )               reduce using rule 32 (factor -> func_call .)


state 15

    (21) assign -> ID . = expr
    (33) factor -> ID .
    (35) func_call -> ID . ( function_argument_list )

    =               shift and go to state 29
    *               reduce using rule 33 (factor -> ID .)
    /               reduce using rule 33 (factor -> ID .)
    ^               reduce using rule 33 (factor -> ID .)
    ;               reduce using rule 33 (factor -> ID .)
    +               reduce using rule 33 (factor -> ID .)
    -               reduce using rule 33 (factor -> ID .)
    (               shift and go to state 30


state 16

    (34) factor -> ( expr . )
    (24) expr -> expr . + term
    (25) expr -> expr . - term

    )               shift and go to state 31
    +               shift and go to state 23
    -               shift and go to state 25


state 17

    (33) factor -> ID .
    (35) func_call -> ID . ( function_argument_list )

    *               reduce using rule 33 (factor -> ID .)
    /               reduce using rule 33 (factor -> ID .)
    ^               reduce using rule 33 (factor -> ID .)
    +               reduce using rule 33 (factor -> ID .)
    -               reduce using rule 33 (factor -> ID .)
    ;               reduce using rule 33 (factor -> ID .)
    )               reduce using rule 33 (factor -> ID .)
    ,               reduce using rule 33 (factor -> ID .)
    (               shift and go to state 30


state 18

    (27) term -> term * . factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    ID              shift and go to state 17
    (               shift and go to state 2

    func_call                      shift and go to state 14
    factor                         shift and go to state 32

state 19

    (29) term -> term ^ . factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    ID              shift and go to state 17
    (               shift and go to state 2

    func_call                      shift and go to state 14
    factor                         shift and go to state 33

state 20

    (28) term -> term / . factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    ID              shift and go to state 17
    (               shift and go to state 2

    func_call                      shift and go to state 14
    factor                         shift and go to state 34

state 21

    (2) program -> program statements .
    (4) statements -> statements . statement
    (5) statement -> . func_def
    (6) statement -> . assign ;
    (7) statement -> . expr ;
    (8) func_def -> . DEF ID ( argument_list ) block
    (20) assign -> . CONST ID = expr
    (21) assign -> . ID = expr
    (23) expr -> . term
    (24) expr -> . expr + term
    (25) expr -> . expr - term
    (26) term -> . factor
    (27) term -> . term * factor
    (28) term -> . term / factor
    (29) term -> . term ^ factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for ( resolved as shift
    $end            reduce using rule 2 (program -> program statements .)
    DEF             shift and go to state 12
    CONST           shift and go to state 7
    ID              shift and go to state 15
    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    (               shift and go to state 2

  ! DEF             [ reduce using rule 2 (program -> program statements .) ]
  ! CONST           [ reduce using rule 2 (program -> program statements .) ]
  ! ID              [ reduce using rule 2 (program -> program statements .) ]
  ! NUMBER          [ reduce using rule 2 (program -> program statements .) ]
  ! STRING          [ reduce using rule 2 (program -> program statements .) ]
  ! (               [ reduce using rule 2 (program -> program statements .) ]

    statement                      shift and go to state 26
    factor                         shift and go to state 4
    expr                           shift and go to state 8
    func_def                       shift and go to state 9
    term                           shift and go to state 5
    assign                         shift and go to state 13
    func_call                      shift and go to state 14

state 22

    (20) assign -> CONST ID . = expr

    =               shift and go to state 35


state 23

    (24) expr -> expr + . term
    (26) term -> . factor
    (27) term -> . term * factor
    (28) term -> . term / factor
    (29) term -> . term ^ factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    ID              shift and go to state 17
    (               shift and go to state 2

    func_call                      shift and go to state 14
    term                           shift and go to state 36
    factor                         shift and go to state 4

state 24

    (7) statement -> expr ; .

    DEF             reduce using rule 7 (statement -> expr ; .)
    CONST           reduce using rule 7 (statement -> expr ; .)
    ID              reduce using rule 7 (statement -> expr ; .)
    NUMBER          reduce using rule 7 (statement -> expr ; .)
    STRING          reduce using rule 7 (statement -> expr ; .)
    (               reduce using rule 7 (statement -> expr ; .)
    $end            reduce using rule 7 (statement -> expr ; .)
    }               reduce using rule 7 (statement -> expr ; .)
    RETURN          reduce using rule 7 (statement -> expr ; .)


state 25

    (25) expr -> expr - . term
    (26) term -> . factor
    (27) term -> . term * factor
    (28) term -> . term / factor
    (29) term -> . term ^ factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    ID              shift and go to state 17
    (               shift and go to state 2

    func_call                      shift and go to state 14
    term                           shift and go to state 37
    factor                         shift and go to state 4

state 26

    (4) statements -> statements statement .

    DEF             reduce using rule 4 (statements -> statements statement .)
    CONST           reduce using rule 4 (statements -> statements statement .)
    ID              reduce using rule 4 (statements -> statements statement .)
    NUMBER          reduce using rule 4 (statements -> statements statement .)
    STRING          reduce using rule 4 (statements -> statements statement .)
    (               reduce using rule 4 (statements -> statements statement .)
    $end            reduce using rule 4 (statements -> statements statement .)
    }               reduce using rule 4 (statements -> statements statement .)
    RETURN          reduce using rule 4 (statements -> statements statement .)


state 27

    (8) func_def -> DEF ID . ( argument_list ) block

    (               shift and go to state 38


state 28

    (6) statement -> assign ; .

    DEF             reduce using rule 6 (statement -> assign ; .)
    CONST           reduce using rule 6 (statement -> assign ; .)
    ID              reduce using rule 6 (statement -> assign ; .)
    NUMBER          reduce using rule 6 (statement -> assign ; .)
    STRING          reduce using rule 6 (statement -> assign ; .)
    (               reduce using rule 6 (statement -> assign ; .)
    $end            reduce using rule 6 (statement -> assign ; .)
    }               reduce using rule 6 (statement -> assign ; .)
    RETURN          reduce using rule 6 (statement -> assign ; .)


state 29

    (21) assign -> ID = . expr
    (23) expr -> . term
    (24) expr -> . expr + term
    (25) expr -> . expr - term
    (26) term -> . factor
    (27) term -> . term * factor
    (28) term -> . term / factor
    (29) term -> . term ^ factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    ID              shift and go to state 17
    (               shift and go to state 2

    expr                           shift and go to state 39
    func_call                      shift and go to state 14
    term                           shift and go to state 5
    factor                         shift and go to state 4

state 30

    (35) func_call -> ID ( . function_argument_list )
    (18) function_argument_list -> . function_argument
    (19) function_argument_list -> . function_argument , function_argument_list
    (17) function_argument -> . expr
    (23) expr -> . term
    (24) expr -> . expr + term
    (25) expr -> . expr - term
    (26) term -> . factor
    (27) term -> . term * factor
    (28) term -> . term / factor
    (29) term -> . term ^ factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    ID              shift and go to state 17
    (               shift and go to state 2

    function_argument              shift and go to state 41
    factor                         shift and go to state 4
    expr                           shift and go to state 40
    function_argument_list         shift and go to state 42
    term                           shift and go to state 5
    func_call                      shift and go to state 14

state 31

    (34) factor -> ( expr ) .

    *               reduce using rule 34 (factor -> ( expr ) .)
    /               reduce using rule 34 (factor -> ( expr ) .)
    ^               reduce using rule 34 (factor -> ( expr ) .)
    +               reduce using rule 34 (factor -> ( expr ) .)
    -               reduce using rule 34 (factor -> ( expr ) .)
    ;               reduce using rule 34 (factor -> ( expr ) .)
    ,               reduce using rule 34 (factor -> ( expr ) .)
    )               reduce using rule 34 (factor -> ( expr ) .)


state 32

    (27) term -> term * factor .

    *               reduce using rule 27 (term -> term * factor .)
    /               reduce using rule 27 (term -> term * factor .)
    ^               reduce using rule 27 (term -> term * factor .)
    ;               reduce using rule 27 (term -> term * factor .)
    +               reduce using rule 27 (term -> term * factor .)
    -               reduce using rule 27 (term -> term * factor .)
    ,               reduce using rule 27 (term -> term * factor .)
    )               reduce using rule 27 (term -> term * factor .)


state 33

    (29) term -> term ^ factor .

    *               reduce using rule 29 (term -> term ^ factor .)
    /               reduce using rule 29 (term -> term ^ factor .)
    ^               reduce using rule 29 (term -> term ^ factor .)
    ;               reduce using rule 29 (term -> term ^ factor .)
    +               reduce using rule 29 (term -> term ^ factor .)
    -               reduce using rule 29 (term -> term ^ factor .)
    ,               reduce using rule 29 (term -> term ^ factor .)
    )               reduce using rule 29 (term -> term ^ factor .)


state 34

    (28) term -> term / factor .

    *               reduce using rule 28 (term -> term / factor .)
    /               reduce using rule 28 (term -> term / factor .)
    ^               reduce using rule 28 (term -> term / factor .)
    ;               reduce using rule 28 (term -> term / factor .)
    +               reduce using rule 28 (term -> term / factor .)
    -               reduce using rule 28 (term -> term / factor .)
    ,               reduce using rule 28 (term -> term / factor .)
    )               reduce using rule 28 (term -> term / factor .)


state 35

    (20) assign -> CONST ID = . expr
    (23) expr -> . term
    (24) expr -> . expr + term
    (25) expr -> . expr - term
    (26) term -> . factor
    (27) term -> . term * factor
    (28) term -> . term / factor
    (29) term -> . term ^ factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    ID              shift and go to state 17
    (               shift and go to state 2

    expr                           shift and go to state 43
    func_call                      shift and go to state 14
    term                           shift and go to state 5
    factor                         shift and go to state 4

state 36

    (24) expr -> expr + term .
    (27) term -> term . * factor
    (28) term -> term . / factor
    (29) term -> term . ^ factor

    +               reduce using rule 24 (expr -> expr + term .)
    -               reduce using rule 24 (expr -> expr + term .)
    ,               reduce using rule 24 (expr -> expr + term .)
    )               reduce using rule 24 (expr -> expr + term .)
    ;               reduce using rule 24 (expr -> expr + term .)
    *               shift and go to state 18
    /               shift and go to state 20
    ^               shift and go to state 19


state 37

    (25) expr -> expr - term .
    (27) term -> term . * factor
    (28) term -> term . / factor
    (29) term -> term . ^ factor

    +               reduce using rule 25 (expr -> expr - term .)
    -               reduce using rule 25 (expr -> expr - term .)
    ,               reduce using rule 25 (expr -> expr - term .)
    )               reduce using rule 25 (expr -> expr - term .)
    ;               reduce using rule 25 (expr -> expr - term .)
    *               shift and go to state 18
    /               shift and go to state 20
    ^               shift and go to state 19


state 38

    (8) func_def -> DEF ID ( . argument_list ) block
    (15) argument_list -> . argument
    (16) argument_list -> . argument , argument_list
    (13) argument -> . expr
    (14) argument -> . default_assign
    (23) expr -> . term
    (24) expr -> . expr + term
    (25) expr -> . expr - term
    (22) default_assign -> . ID = expr
    (26) term -> . factor
    (27) term -> . term * factor
    (28) term -> . term / factor
    (29) term -> . term ^ factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

    ID              shift and go to state 48
    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    (               shift and go to state 2

    default_assign                 shift and go to state 44
    argument                       shift and go to state 45
    argument_list                  shift and go to state 46
    expr                           shift and go to state 47
    factor                         shift and go to state 4
    term                           shift and go to state 5
    func_call                      shift and go to state 14

state 39

    (21) assign -> ID = expr .
    (24) expr -> expr . + term
    (25) expr -> expr . - term

    ;               reduce using rule 21 (assign -> ID = expr .)
    +               shift and go to state 23
    -               shift and go to state 25


state 40

    (17) function_argument -> expr .
    (24) expr -> expr . + term
    (25) expr -> expr . - term

    ,               reduce using rule 17 (function_argument -> expr .)
    )               reduce using rule 17 (function_argument -> expr .)
    +               shift and go to state 23
    -               shift and go to state 25


state 41

    (18) function_argument_list -> function_argument .
    (19) function_argument_list -> function_argument . , function_argument_list

    )               reduce using rule 18 (function_argument_list -> function_argument .)
    ,               shift and go to state 49


state 42

    (35) func_call -> ID ( function_argument_list . )

    )               shift and go to state 50


state 43

    (20) assign -> CONST ID = expr .
    (24) expr -> expr . + term
    (25) expr -> expr . - term

    ;               reduce using rule 20 (assign -> CONST ID = expr .)
    +               shift and go to state 23
    -               shift and go to state 25


state 44

    (14) argument -> default_assign .

    ,               reduce using rule 14 (argument -> default_assign .)
    )               reduce using rule 14 (argument -> default_assign .)


state 45

    (15) argument_list -> argument .
    (16) argument_list -> argument . , argument_list

    )               reduce using rule 15 (argument_list -> argument .)
    ,               shift and go to state 51


state 46

    (8) func_def -> DEF ID ( argument_list . ) block

    )               shift and go to state 52


state 47

    (13) argument -> expr .
    (24) expr -> expr . + term
    (25) expr -> expr . - term

    ,               reduce using rule 13 (argument -> expr .)
    )               reduce using rule 13 (argument -> expr .)
    +               shift and go to state 23
    -               shift and go to state 25


state 48

    (22) default_assign -> ID . = expr
    (33) factor -> ID .
    (35) func_call -> ID . ( function_argument_list )

    =               shift and go to state 53
    *               reduce using rule 33 (factor -> ID .)
    /               reduce using rule 33 (factor -> ID .)
    ^               reduce using rule 33 (factor -> ID .)
    +               reduce using rule 33 (factor -> ID .)
    -               reduce using rule 33 (factor -> ID .)
    ,               reduce using rule 33 (factor -> ID .)
    )               reduce using rule 33 (factor -> ID .)
    (               shift and go to state 30


state 49

    (19) function_argument_list -> function_argument , . function_argument_list
    (18) function_argument_list -> . function_argument
    (19) function_argument_list -> . function_argument , function_argument_list
    (17) function_argument -> . expr
    (23) expr -> . term
    (24) expr -> . expr + term
    (25) expr -> . expr - term
    (26) term -> . factor
    (27) term -> . term * factor
    (28) term -> . term / factor
    (29) term -> . term ^ factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    ID              shift and go to state 17
    (               shift and go to state 2

    function_argument              shift and go to state 41
    factor                         shift and go to state 4
    expr                           shift and go to state 40
    function_argument_list         shift and go to state 54
    term                           shift and go to state 5
    func_call                      shift and go to state 14

state 50

    (35) func_call -> ID ( function_argument_list ) .

    *               reduce using rule 35 (func_call -> ID ( function_argument_list ) .)
    /               reduce using rule 35 (func_call -> ID ( function_argument_list ) .)
    ^               reduce using rule 35 (func_call -> ID ( function_argument_list ) .)
    ;               reduce using rule 35 (func_call -> ID ( function_argument_list ) .)
    +               reduce using rule 35 (func_call -> ID ( function_argument_list ) .)
    -               reduce using rule 35 (func_call -> ID ( function_argument_list ) .)
    ,               reduce using rule 35 (func_call -> ID ( function_argument_list ) .)
    )               reduce using rule 35 (func_call -> ID ( function_argument_list ) .)


state 51

    (16) argument_list -> argument , . argument_list
    (15) argument_list -> . argument
    (16) argument_list -> . argument , argument_list
    (13) argument -> . expr
    (14) argument -> . default_assign
    (23) expr -> . term
    (24) expr -> . expr + term
    (25) expr -> . expr - term
    (22) default_assign -> . ID = expr
    (26) term -> . factor
    (27) term -> . term * factor
    (28) term -> . term / factor
    (29) term -> . term ^ factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

    ID              shift and go to state 48
    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    (               shift and go to state 2

    default_assign                 shift and go to state 44
    argument                       shift and go to state 45
    argument_list                  shift and go to state 55
    expr                           shift and go to state 47
    factor                         shift and go to state 4
    term                           shift and go to state 5
    func_call                      shift and go to state 14

state 52

    (8) func_def -> DEF ID ( argument_list ) . block
    (9) block -> . { }
    (10) block -> . { statements }
    (11) block -> . { statements RETURN expr ; }
    (12) block -> . { RETURN expr ; }

    {               shift and go to state 57

    block                          shift and go to state 56

state 53

    (22) default_assign -> ID = . expr
    (23) expr -> . term
    (24) expr -> . expr + term
    (25) expr -> . expr - term
    (26) term -> . factor
    (27) term -> . term * factor
    (28) term -> . term / factor
    (29) term -> . term ^ factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    ID              shift and go to state 17
    (               shift and go to state 2

    expr                           shift and go to state 58
    func_call                      shift and go to state 14
    term                           shift and go to state 5
    factor                         shift and go to state 4

state 54

    (19) function_argument_list -> function_argument , function_argument_list .

    )               reduce using rule 19 (function_argument_list -> function_argument , function_argument_list .)


state 55

    (16) argument_list -> argument , argument_list .

    )               reduce using rule 16 (argument_list -> argument , argument_list .)


state 56

    (8) func_def -> DEF ID ( argument_list ) block .

    }               reduce using rule 8 (func_def -> DEF ID ( argument_list ) block .)
    RETURN          reduce using rule 8 (func_def -> DEF ID ( argument_list ) block .)
    DEF             reduce using rule 8 (func_def -> DEF ID ( argument_list ) block .)
    CONST           reduce using rule 8 (func_def -> DEF ID ( argument_list ) block .)
    ID              reduce using rule 8 (func_def -> DEF ID ( argument_list ) block .)
    NUMBER          reduce using rule 8 (func_def -> DEF ID ( argument_list ) block .)
    STRING          reduce using rule 8 (func_def -> DEF ID ( argument_list ) block .)
    (               reduce using rule 8 (func_def -> DEF ID ( argument_list ) block .)
    $end            reduce using rule 8 (func_def -> DEF ID ( argument_list ) block .)


state 57

    (9) block -> { . }
    (10) block -> { . statements }
    (11) block -> { . statements RETURN expr ; }
    (12) block -> { . RETURN expr ; }
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . func_def
    (6) statement -> . assign ;
    (7) statement -> . expr ;
    (8) func_def -> . DEF ID ( argument_list ) block
    (20) assign -> . CONST ID = expr
    (21) assign -> . ID = expr
    (23) expr -> . term
    (24) expr -> . expr + term
    (25) expr -> . expr - term
    (26) term -> . factor
    (27) term -> . term * factor
    (28) term -> . term / factor
    (29) term -> . term ^ factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

    }               shift and go to state 59
    RETURN          shift and go to state 61
    DEF             shift and go to state 12
    CONST           shift and go to state 7
    ID              shift and go to state 15
    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    (               shift and go to state 2

    statement                      shift and go to state 1
    statements                     shift and go to state 60
    factor                         shift and go to state 4
    func_def                       shift and go to state 9
    expr                           shift and go to state 8
    assign                         shift and go to state 13
    term                           shift and go to state 5
    func_call                      shift and go to state 14

state 58

    (22) default_assign -> ID = expr .
    (24) expr -> expr . + term
    (25) expr -> expr . - term

    ,               reduce using rule 22 (default_assign -> ID = expr .)
    )               reduce using rule 22 (default_assign -> ID = expr .)
    +               shift and go to state 23
    -               shift and go to state 25


state 59

    (9) block -> { } .

    DEF             reduce using rule 9 (block -> { } .)
    CONST           reduce using rule 9 (block -> { } .)
    ID              reduce using rule 9 (block -> { } .)
    NUMBER          reduce using rule 9 (block -> { } .)
    STRING          reduce using rule 9 (block -> { } .)
    (               reduce using rule 9 (block -> { } .)
    $end            reduce using rule 9 (block -> { } .)
    }               reduce using rule 9 (block -> { } .)
    RETURN          reduce using rule 9 (block -> { } .)


state 60

    (10) block -> { statements . }
    (11) block -> { statements . RETURN expr ; }
    (4) statements -> statements . statement
    (5) statement -> . func_def
    (6) statement -> . assign ;
    (7) statement -> . expr ;
    (8) func_def -> . DEF ID ( argument_list ) block
    (20) assign -> . CONST ID = expr
    (21) assign -> . ID = expr
    (23) expr -> . term
    (24) expr -> . expr + term
    (25) expr -> . expr - term
    (26) term -> . factor
    (27) term -> . term * factor
    (28) term -> . term / factor
    (29) term -> . term ^ factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

    }               shift and go to state 62
    RETURN          shift and go to state 63
    DEF             shift and go to state 12
    CONST           shift and go to state 7
    ID              shift and go to state 15
    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    (               shift and go to state 2

    statement                      shift and go to state 26
    factor                         shift and go to state 4
    func_def                       shift and go to state 9
    expr                           shift and go to state 8
    assign                         shift and go to state 13
    term                           shift and go to state 5
    func_call                      shift and go to state 14

state 61

    (12) block -> { RETURN . expr ; }
    (23) expr -> . term
    (24) expr -> . expr + term
    (25) expr -> . expr - term
    (26) term -> . factor
    (27) term -> . term * factor
    (28) term -> . term / factor
    (29) term -> . term ^ factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    ID              shift and go to state 17
    (               shift and go to state 2

    expr                           shift and go to state 64
    func_call                      shift and go to state 14
    term                           shift and go to state 5
    factor                         shift and go to state 4

state 62

    (10) block -> { statements } .

    DEF             reduce using rule 10 (block -> { statements } .)
    CONST           reduce using rule 10 (block -> { statements } .)
    ID              reduce using rule 10 (block -> { statements } .)
    NUMBER          reduce using rule 10 (block -> { statements } .)
    STRING          reduce using rule 10 (block -> { statements } .)
    (               reduce using rule 10 (block -> { statements } .)
    $end            reduce using rule 10 (block -> { statements } .)
    }               reduce using rule 10 (block -> { statements } .)
    RETURN          reduce using rule 10 (block -> { statements } .)


state 63

    (11) block -> { statements RETURN . expr ; }
    (23) expr -> . term
    (24) expr -> . expr + term
    (25) expr -> . expr - term
    (26) term -> . factor
    (27) term -> . term * factor
    (28) term -> . term / factor
    (29) term -> . term ^ factor
    (30) factor -> . NUMBER
    (31) factor -> . STRING
    (32) factor -> . func_call
    (33) factor -> . ID
    (34) factor -> . ( expr )
    (35) func_call -> . ID ( function_argument_list )

    NUMBER          shift and go to state 3
    STRING          shift and go to state 11
    ID              shift and go to state 17
    (               shift and go to state 2

    factor                         shift and go to state 4
    expr                           shift and go to state 65
    term                           shift and go to state 5
    func_call                      shift and go to state 14

state 64

    (12) block -> { RETURN expr . ; }
    (24) expr -> expr . + term
    (25) expr -> expr . - term

    ;               shift and go to state 66
    +               shift and go to state 23
    -               shift and go to state 25


state 65

    (11) block -> { statements RETURN expr . ; }
    (24) expr -> expr . + term
    (25) expr -> expr . - term

    ;               shift and go to state 67
    +               shift and go to state 23
    -               shift and go to state 25


state 66

    (12) block -> { RETURN expr ; . }

    }               shift and go to state 68


state 67

    (11) block -> { statements RETURN expr ; . }

    }               shift and go to state 69


state 68

    (12) block -> { RETURN expr ; } .

    DEF             reduce using rule 12 (block -> { RETURN expr ; } .)
    CONST           reduce using rule 12 (block -> { RETURN expr ; } .)
    ID              reduce using rule 12 (block -> { RETURN expr ; } .)
    NUMBER          reduce using rule 12 (block -> { RETURN expr ; } .)
    STRING          reduce using rule 12 (block -> { RETURN expr ; } .)
    (               reduce using rule 12 (block -> { RETURN expr ; } .)
    $end            reduce using rule 12 (block -> { RETURN expr ; } .)
    }               reduce using rule 12 (block -> { RETURN expr ; } .)
    RETURN          reduce using rule 12 (block -> { RETURN expr ; } .)


state 69

    (11) block -> { statements RETURN expr ; } .

    DEF             reduce using rule 11 (block -> { statements RETURN expr ; } .)
    CONST           reduce using rule 11 (block -> { statements RETURN expr ; } .)
    ID              reduce using rule 11 (block -> { statements RETURN expr ; } .)
    NUMBER          reduce using rule 11 (block -> { statements RETURN expr ; } .)
    STRING          reduce using rule 11 (block -> { statements RETURN expr ; } .)
    (               reduce using rule 11 (block -> { statements RETURN expr ; } .)
    $end            reduce using rule 11 (block -> { statements RETURN expr ; } .)
    }               reduce using rule 11 (block -> { statements RETURN expr ; } .)
    RETURN          reduce using rule 11 (block -> { statements RETURN expr ; } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DEF in state 10 resolved as shift
WARNING: shift/reduce conflict for CONST in state 10 resolved as shift
WARNING: shift/reduce conflict for ID in state 10 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 10 resolved as shift
WARNING: shift/reduce conflict for STRING in state 10 resolved as shift
WARNING: shift/reduce conflict for ( in state 10 resolved as shift
WARNING: shift/reduce conflict for DEF in state 21 resolved as shift
WARNING: shift/reduce conflict for CONST in state 21 resolved as shift
WARNING: shift/reduce conflict for ID in state 21 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 21 resolved as shift
WARNING: shift/reduce conflict for STRING in state 21 resolved as shift
WARNING: shift/reduce conflict for ( in state 21 resolved as shift
